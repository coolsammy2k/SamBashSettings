#AppArmor 

$ cat /sys/module/apparmor/parameters/enabled
Y

$ cat /sys/kernel/security/apparmor/profiles


# Create Custom application specific profiles from scratch
# As an Example, let's consider a simple bash script which creates directories in a particular directory

add_data.sh

#!/bin/bash
data_directory=/opt/app/data
mkdir -p ${data_directory}
echo "=> File created at `date` " | tee ${data_directory} create.log



$ apt-get install -y apparmor-utils

# create a profile for the shell script using aa-genprof command

$ aa-genprof /root/add_data.sh

#After completing the questions from above command run aa-status command to check the status of the profile 
$ aa-status

# The profiles are stored under the directory
  cat /etc/apparmor.d/root.add_data.sh



# Load Apparmor Profile

Profiles are configured in three modes
1. Enforce
2. Complain
3. Unconfined


# How to work with existing apparmor profile
# To load a profile run the below command

$ apparmor_parser -q /etc/apparmor.d/usr.sbin.nginx

# To disable the profile
$ apparmor_parser -R /etc/apparmor.d/root.add_data.sh
$ ln -s /etc/apparmor.d/root.add_data.sh /etc/apparmor.d/disable/

# AppArmor security profiles for Docker

# Load and unload profiles

To load a new profile into AppArmor for use with containers:

$ apparmor_parser -r -W /path/to/your_profile

Then, run the custom profile with --security-opt like so:

$ docker run --rm -it --security-opt apparmor=your_profile hello-world


To unload a profile from AppArmor:
# unload the profile
$ apparmor_parser -R /path/to/profile


Run without the default seccomp profile
You can pass unconfined to run a container without the default seccomp profile.
$ docker run --rm -it --security-opt seccomp=unconfined debian:jessie \
    unshare --map-root-user --user sh -c whoami

Restrict a Container's Access to Resources with AppArmor
https://kubernetes.io/docs/tutorials/clusters/apparmor/#setting-up-nodes-with-profiles

	1. Command to verify the Kubelet version of your nodes:
       $ kubectl get nodes -o=jsonpath=$'{range .items[*]}{@.metadata.name}: {@.status.nodeInfo.kubeletVersion}\n{end}'

	2. AppArmor kernel module is enabled. To check whether the module is enabled, check the /sys/module/apparmor/parameters/enabled file:
	
	   $ cat /sys/module/apparmor/parameters/enabled
         Y


	3. Profile is loaded -- AppArmor is applied to a Pod by specifying an AppArmor profile that each container should be run with. You can view which profiles are loaded on a node by checking the /sys/kernel/security/apparmor/profiles file. For example:

          $ ssh gke-test-default-pool-239f5d02-gyn2 "sudo cat /sys/kernel/security/apparmor/profiles | sort"

	4. You can also verify AppArmor support on nodes by checking the node ready condition message (though this is likely to be removed in a later release):
          $ kubectl get nodes -o=jsonpath=$'{range .items[*]}{@.metadata.name}: {.status.conditions[?(@.reason=="KubeletReady")].message}\n{end}'

	5. You can also verify directly that the container's root process is running with the correct profile by checking its proc attr:
          $ kubectl exec <pod_name> cat /proc/1/attr/current

Restrict a Container's Syscalls with Seccomp
https://kubernetes.io/docs/tutorials/clusters/seccomp/


Configure a Security Context for a Pod or Container
https://kubernetes.io/docs/tasks/configure-pod-container/security-context/


---

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: nginx
  name: audit-nginx
spec:
  securityContext:
    seccompProfile:
      type: Localhost
      localhostProfile: profiles/audit.json
  containers:
  - image: nginx
    name: nginx
