Pod with ServiceAccount uses Secrets
  Create new Namespace ns-secure and perform everything else in there
  Create ServiceAccount secret-manager
  Create Secret sec-a1 with any literal content of your choice
  Create Secret sec-a2 with any file content of your choice (like /etc/hosts)
  Create Pod secret-manager image nginx which uses the new SA
  Make Secret sec-a1 available as environment variable SEC_A1
  Mount Secret sec-a2 into the Pod read-only under /etc/sec-a2
  Verify your solution worked


  Solution
To solve this weâ€™re logged into our controlplane node cks-controlplane .
1.
  alias k=kubectl
  k create ns ns-secure

2.
  k -n ns-secure create sa secret-manager
3.
  k -n ns-secure create secret generic sec-a1 --from-literal user=admin
4.
  k -n ns-secure create secret generic sec-a2 --from-file index=/etc/hosts

5. 6. 7.
  k -n ns-secure run secret-manager --image=nginx -oyaml --dry-run=client > pod.yaml
Now edit the yaml to:

apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: secret-manager
  name: secret-manager
  namespace: ns-secure
spec:
  volumes:
    - name: sec-a2
      secret:
        secretName: sec-a2
  serviceAccountName: secret-manager
  containers:
    - image: nginx
      name: secret-manager
      volumeMounts:
        - name: sec-a2
          mountPath: /etc/sec-a2
          readOnly: true
      env:
        - name: SEC_A1
          valueFrom:
            secretKeyRef:
              name: sec-a1
              key: user
  dnsPolicy: ClusterFirst
  restartPolicy: Always

8.
And to verify:
  k -f pod.yaml create
  k -n ns-secure exec secret-manager -- env | grep SEC
  k -n ns-secure exec secret-manager -- mount | grep sec
---

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: deploy1
  name: deploy1
spec:
  replicas: 2
  selector:
    matchLabels:
      app: deploy1
  template:
    metadata:
      labels:
        app: deploy1
    spec:
      serviceAccountName: special
      containers:
      - image: nginx
        name: nginx

---

apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: pod1
  name: pod1
spec:
  automountServiceAccountToken: false
  containers:
  - image: nginx
    name: pod1
---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: special
  namespace: default
automountServiceAccountToken: false

---

k rollout restart deploy deploy1
k exec deploy1-775d6566dc-bq757 -- mount | grep serviceaccount
k exec deploy1-775d6566dc-qwthl -- mount | grep serviceaccount


#How to find which role or clusterrole binded to a service account in Kubernetes?

kubectl get rolebindings,clusterrolebindings \
  --all-namespaces  \
    -o custom-columns='KIND:kind,NAMESPACE:metadata.namespace,NAME:metadata.name,SERVICE_ACCOUNTS:subjects[?(@.kind=="ServiceAccount")].name' | grep "<SERVICE_ACCOUNT_NAME>"


#Access API token from secret of default service account

APISERVER=$(kubectl config view --minify | grep server | cut -f 2- -d ":" | tr -d " ")
SECRET_NAME=$(kubectl get secrets | grep ^default | cut -f1 -d ' ')
TOKEN=$(kubectl describe secret $SECRET_NAME | grep -E '^token' | cut -f2 -d':' | tr -d " ")

curl $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure

# Using jsonpath

APISERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
SECRET_NAME=$(kubectl get serviceaccount default -o jsonpath='{.secrets[0].name}')
TOKEN=$(kubectl get secret $SECRET_NAME -o jsonpath='{.data.token}' | base64 --decode)

curl $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure
